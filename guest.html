<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Join — Guest</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:Arial,system-ui;margin:12px}
    video{width:100%;max-height:50vh;background:#000}
    button{padding:10px 14px;margin:6px}
    .status{margin-top:8px;color:#333}
  </style>
</head>
<body>
  <h2>Join Interview</h2>
  <div id="info">Connecting...</div>
  <video id="local" autoplay playsinline muted></video>
  <div>
    <button id="joinBtn">Join Room</button>
    <button id="leaveBtn" style="display:none">Leave</button>
  </div>
  <div class="status" id="status"></div>

<script src="/socket.io/socket.io.js"></script>
<script>
(async function(){
  const socket = io();
  const urlParts = location.pathname.split('/');
  // expected URL: /room/<id>/guest  OR query ?room=...
  let room = urlParts.includes('room') ? urlParts[urlParts.indexOf('room')+1] : (new URL(location)).searchParams.get('room') || 'default';
  const localVideo = document.getElementById('local');
  const status = document.getElementById('status');
  const joinBtn = document.getElementById('joinBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  let localStream, pc;

  function log(s){ status.innerText = s; }

  // join as guest (in lobby)
  socket.emit('join', { role: 'guest', room, name: 'Guest' }, (res) => {
    if (res && res.error) log('Room not found');
    else log('Waiting in lobby. Host will accept you.');
  });

  socket.on('accepted', async ({ room: rm, hostId }) => {
    log('Accepted by host — connecting...');
    // start getUserMedia & create peer
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
      localVideo.srcObject = localStream;
    } catch (e) {
      log('Camera/mic permission denied: ' + e.message);
      return;
    }
    // create a RTCPeerConnection and send offer to host via signaling
    pc = new RTCPeerConnection({ iceServers: [{ urls:'stun:stun.l.google.com:19302' }] });
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    pc.onicecandidate = (evt) => {
      if (evt.candidate) socket.emit('signal', { to: hostId, type: 'ice', data: evt.candidate });
    };
    pc.onconnectionstatechange = ()=> log('Conn: '+ pc.connectionState);

    // collect remote tracks (if host sends any)
    pc.ontrack = (e)=> { console.log('remote track', e); };

    // create offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit('signal', { to: hostId, type: 'offer', data: offer });
  });

  socket.on('signal', async ({ from, type, data }) => {
    try {
      if (!pc) {
        // create pc if not exists (answerer case)
        pc = new RTCPeerConnection({ iceServers: [{ urls:'stun:stun.l.google.com:19302' }] });
        if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        pc.onicecandidate = (evt)=> { if(evt.candidate) socket.emit('signal', { to: from, type:'ice', data: evt.candidate }); };
      }
      if (type === 'answer') {
        await pc.setRemoteDescription(new RTCSessionDescription(data));
      } else if (type === 'ice') {
        await pc.addIceCandidate(new RTCIceCandidate(data));
      } else if (type === 'offer') {
        await pc.setRemoteDescription(new RTCSessionDescription(data));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('signal', { to: from, type: 'answer', data: answer });
      }
    } catch (e) { console.error(e); }
  });

  socket.on('mute', ({ what }) => {
    // basic mute: stop audio track if asked
    if (localStream && what === 'audio') {
      localStream.getAudioTracks().forEach(t => t.enabled = false);
      log('You were muted by host');
    }
    if (localStream && what === 'unmute') {
      localStream.getAudioTracks().forEach(t => t.enabled = true);
      log('You were unmuted by host');
    }
  });

  socket.on('kicked', ({ reason }) => {
    log('You were removed: ' + (reason||''));
    if (pc) pc.close();
    if (localStream) localStream.getTracks().forEach(t=>t.stop());
  });

  socket.on('rejected', () => {
    log('Host rejected your request');
  });

})();
</script>
</body>
</html>
